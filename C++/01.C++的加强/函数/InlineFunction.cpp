/*内联函数
	1) C99也支持，但C89不支持
	2) 在调用函数时，会保存函数调用处的现场信息，调用函数返回后，恢复现场，接着之前的位置继续往下执行，所以调用函数会有一定的时间和空间开销。如果函数体中只有几行代码，调用函数的时间开销甚至比执行函数体中的语句更大。
	3) 在调用函数时，操作系统会为这次函数调用创建一个独立的栈区，用于存放函数的形参和内部定义的局部变量，在函数执行结束返回后，操作系统会释放这个栈区，那么栈区中的这些变量也就跟着被释放了。 （压栈、跳转、返回）
	4) 定义内联函数，使用inline关键字 
*/
#include <iostream>
using namespace std;
inline int sum(int a, int b);

int main()
{
	int s;
	//编译器在遇到内联函数调用时，会将函数调用展开为内联函数体，避免函数调用的时空开销，提升程序运行效率。
	//内联函数中的代码不要太多，太复杂。
	s=sum(3,4); //编译器会把这行处理为：s=3+4;
	cout<<s<<endl;
	return 0;
}
//定义内联函数，使用inline关键字
inline int sum(int a, int b)
{
	return a+b;
}

/*
	内联函数也是一种请求，编译器可能会拒绝。
	内联函数由编译器处理，直接将编译后的函数体插入调用的地方。
	宏代码片段由预处理器处理，进行简单的文本替换，没有任何编译过程。

	现代C++编译器能够进行编译优化，因此一些函数即使没有inline声明，也可能被编译器内联编译
	另外，一些现代C++编译器提供了扩展语法，能够对函数进行强制内联
	如：g++中的__attribute__((always_inline))属性

	C++中内联编译的限制：
		不能存在任何形式的循环语句   
		不能存在过多的条件判断语句
		函数体不能过于庞大
		不能对函数进行取址操作
		函数内联声明必须在调用语句之前

	编译器对于内联函数的限制并不是绝对的，内联函数相对于普通函数的优势只是省去了函数调用时压栈，跳转和返回的开销。
	因此，当函数体的执行开销远大于压栈，跳转和返回所用的开销时，那么内联将无意义。
*/