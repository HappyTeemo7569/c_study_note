/**********************
不加多态，则不管传来是父类对象还是子类对象，都是执行父类函数。
加了多态，则传来的对象不同，会调用相应的函数。
***********************/

#include<iostream>
using namespace std;

class Parent
{
public:
	Parent(int a = 0)
	{
		this->a = a;
	}
	//void print() 
	virtual void print()    //多态
	{
		cout<<"P a"<<a<<endl;
	}
	virtual void print2()    //多态，和不多态效果一样，子类没有自己的就会用父类的。
	{
		cout<<"P2 a"<<a<<endl;
	}
protected:
private:
	int a;
};

class Child : public Parent
{
public:
	Child(int b = 0)
	{
		this->b = b;
	}
	//void print()  
	virtual void print()  //多态
	{
		cout<<"C b"<<b<<endl;
	}
protected:
private:
	int b;
};

void howToPrintf(Parent *base)
{
	base->print(); //同样一句话，能实现多种功能；有多种形态
}

void howToPrintf2(Parent &base)
{
	base.print(); //同样一句话，能实现多种功能；有多种形态
}

int main()
{
	Parent  p1;
	p1.print();   //ok -》a

	Child   c1;
	c1.print();  //ok-》 b    子类与父类有重复、相同函数时，用自己的
		
	Parent *base = NULL;  //父类指针
	base = &p1;
	base->print(); // -》a
		
	base = &c1; // 父类指针指向子类
	//Child *pC = &p1;错误，不可以把父类对象赋给子类指针
	base->print(); //不多态打印父类，多态后指向子类的函数

	Parent &p2 = c1;    // p2(父类)引用 是c1的别名 ，是c1本身 (子类)
	p2.print();   //不多态打印父类，多态后指向子类的函数

	//函数参数      指针
	howToPrintf(&p1); //父类
	howToPrintf(&c1); //不多态打印父类，多态后指向子类的函数

	//引用
	howToPrintf2(p1); //父类
	howToPrintf2(c1); //不多态打印父类，多态后指向子类的函数
	

	c1.print2();//没有自己的，用父类的。这里多态和不多态效果一样。
	return 0;
}

/*
void print()不加virtual情况下
1.有赋值兼容性原则 说不会报错
2.C++默认是静态编译语言编译时，编译器会自动根据指针类型判断指向的是一个什么样的对象
	1.在编译此函数时，编译器不可能知道指针指向了什么。
	2.编译器没有理由报错。
	3.于是，编译器认为最安全的做法是编译到父类，因为父类和子类肯定有相同的函数。
3.如果基类中加上virtual关键字，C++编译器会动手脚====》动态链接编译

C++编译器会来一个迟绑定(子类-》子类，父类-》父类)
多态性编译的两种方式：
静态绑定（早绑定）：在编译时，确定函数调用表达式，与那个函数体（或代码）绑定在一起。这时就支持静态多态性。
动态绑定（晚绑定vptr）（运行时多态性）：在运行时，确定函数调用表达式，与那个函数体（或代码）绑定在一起。
这时就支持动态多态性（也叫运行时的多态性）。
*/

/************************************************************************/
/* 
实现过程：
虚函数表，V-table,vftable。
类中有虚函数时，每个对象都会有一个指向虚函数表的指针（vptr指针）
表中存放各个虚函数方法的指针，子类不重写则拷贝一份，重写了则将对应函数的指针重定向。
举例：传入父类对象， 则找到父类的指针，看里面的指向的方法。
	传入子类对象，则子类的指针默认指向的是父类的方法， 重写了则重定向到子类自己的方法。
*/
/************************************************************************/

/*
说明1：
通过虚函数表指针VPTR调用重写函数是在程序运行时进行的，因此需要通过寻址操作才能确定真正应该调用的函数。
而普通成员函数是在编译时就确定了调用的函数。在效率上，虚函数的效率要低很多。
说明2：
出于效率考虑，没有必要将所有成员函数都声明为虚函数
*/